genes_named_vector.tail(0)
genes_named_vector.tail()
genes_named_vector.tail
genes_named_vector[16000:16500]
celltypes <- unique(bmcite$celltype.l2)
n_celltypes <- length(celltypes )
cell_clusters = rep(0, length(celltypes ))
for (i in 1:n_celltypes ){
celltype = celltypes[i]
indices = which(bmcite$celltype.l2==celltype)
cell_clusters[indices] = i
}
res_data <- ScaleData(bmcite,all.genes,split.by = "celltype.l2",
do.scale = FALSE,do.center = TRUE)
rm(bmcite)
res_data <- ScaleData(bmcite,all.genes,
do.scale = FALSE,do.center = TRUE)
load(file='/Users/bencekover/Library/CloudStorage/OneDrive-UniversityCollegeLondon/duchen lab/rna seq/seurat data/unpacked data/data files/bmcite.rda')
res_data <- ScaleData(bmcite,all.genes,
do.scale = FALSE,do.center = TRUE)
matrix_mod<-as.matrix(res_data)
rm(matrix_mod)
rm(res_data)
res_data <- ScaleData(bmcite,all.genes,
do.scale = FALSE,do.center = TRUE)
matrix_mod<-as.matrix(res_data)
res_data <- ScaleData(bmcite,all.genes,
do.scale = FALSE,do.center = TRUE)
matrix_mod<-as.matrix(res_data[["RNA"]]@scale.data)
rm(red_data)
gene<-as.numeric(matrix_mod["ATPIF1",])
correlations_p<-apply(matrix_mod,1,function(x){cor.test(gene,x)$p.value})
correlations_r<-apply(matrix_mod,1,function(x){cor.test(gene,x)$estimate})
corr_tibb <-tibble(cor_p = correlations_p,
cor_r = correlations_r, gene = all.genes,
index = 1:length(all.genes))
corr_tibb <- corr_tibb %>%
filter(gene!="ATPIF1")%>%
mutate(p_adj = cor_p*length(all.genes)) %>% arrange(p_adj)
print(corr_tibb)
rm(res_mat)
gsea_tibb <- corr_tibb %>% arrange(desc(cor_r))
genes_named_vector <- gsea_tibb$cor_r
names(genes_named_vector) <- gsea_tibb$gene
genes_named_vector[is.na(genes_named_vector)] <- 0
GOdata <- new("topGOdata",
ontology = "BP", # use biological process ontology
allGenes = genes_named_vector ,
geneSel = function(x)(abs(x)>max(genes_named_vector[1:1000])),
nodeSize = 5,
annot = annFUN.org, mapping = "org.Hs.eg.db", ID = "symbol")
resultks <- runTest(GOdata, algorithm = "elim", statistic = "ks")
gentab <- GenTable(GOdata, ks = resultks, topNodes = 50, numChar = 80)
print(showGroupDensity(GOdata, "GO:0002181", ranks = TRUE)) #translation
print(gentab)
rm(res_data)
mean(matrix_mod[1,])
mean(matrix_mod[59,])
mean(matrix_mod[765,])
mean(matrix_mod["ATPIF1",])
mean(matrix_mod[333,])
knitr::opts_chunk$set(echo = TRUE)
#BiocManager::install("topGO")
#install.packages("org.Hs.eg.db")
library(tidyverse)
library(Seurat)
library(SeuratData)
library(patchwork)
library(sctransform)
library(readr)
library(data.table)
library(topGO)
load(file='/Users/bencekover/Library/CloudStorage/OneDrive-UniversityCollegeLondon/duchen lab/rna seq/seurat data/unpacked data/data files/bmcite.rda')
filter_data <-function(seuratobj){
seuratobj[["percent.mt"]] <- PercentageFeatureSet(seuratobj, pattern = "^MT-")
min_feat = quantile(seuratobj[["nFeature_RNA"]]$nFeature_RNA, 0.2)
min_count = quantile(seuratobj[["nCount_RNA"]]$nCount_RNA, 0.2)
min_mt = min(quantile(seuratobj[["percent.mt"]]$percent.mt, 0.2), 5)
max_feat = quantile(seuratobj[["nFeature_RNA"]]$nFeature_RNA, 0.98)
max_count = quantile(seuratobj[["nCount_RNA"]]$nCount_RNA, 0.98)
max_mt = quantile(seuratobj[["percent.mt"]]$percent.mt, 0.98)
so <- subset(seuratobj, subset = nFeature_RNA > min_feat  &
nFeature_RNA < max_feat  &
nCount_RNA > min_count &
nCount_RNA < max_count &
percent.mt > min_mt & percent.mt < max_mt)
return(so)
}
bmcite <- filter_data(bmcite)
VlnPlot(bmcite, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
all.genes <- rownames(bmcite)
bmcite <- FindVariableFeatures(bmcite, selection.method = "vst", nfeatures = 2000)
bmcite <- NormalizeData(bmcite, normalization.method = "LogNormalize", scale.factor = 10000)
bmcite <- ScaleData(bmcite, features = all.genes)
bmcite <- RunPCA(bmcite, features = VariableFeatures(object = bmcite))
ElbowPlot(bmcite, 30)
VlnPlot(bmcite, features = c("ATPIF1","ATP5A1"),group.by= "celltype.l2")
print(FindMarkers(bmcite,group.by ="celltype.l2", "Prog_RBC", features = "ATPIF1"))
bmcite <- FindNeighbors(bmcite, dims = 1:25)
bmcite <- FindClusters(bmcite, resolution = 0.2)
bmcite <- RunUMAP(bmcite, dims = 1:25)
DimPlot(bmcite, reduction = "umap",group.by= "celltype.l2", label=T)
FeaturePlot(bmcite, reduction = "umap",features = c("ATPIF1"))
#also finding the index of IF1 and ATP5A
if ("ATPIF1" %in% all.genes) {
print("ATPIF1 is in all genes")
if ("ATP5A1" %in% all.genes) {
print("ATP5A1 is in all genes")
atp5_index <- which(all.genes == "ATP5A1")
}
if1_index <- which(all.genes == "ATPIF1")
}
count_mat <- bmcite[["RNA"]]@data
rm(count_mat)
matrix_mod<-as.matrix(count_mat)
count_mat <- bmcite[["RNA"]]@data
matrix_mod<-as.matrix(count_mat)
rm(count_mat)
gene<-as.numeric(matrix_mod["ATPIF1",])
correlations_p<-apply(matrix_mod,1,function(x){cor.test(gene,x)$p.value})
correlations_r<-apply(matrix_mod,1,function(x){cor.test(gene,x)$estimate})
corr_tibb <-tibble(cor_p = correlations_p,
cor_r = correlations_r, gene = all.genes,
index = 1:length(all.genes))
corr_tibb <- corr_tibb %>%
filter(gene!="ATPIF1")%>%
mutate(p_adj = cor_p*length(all.genes)) %>% arrange(p_adj)
print(corr_tibb)
highest_corr_gene_index <- corr_tibb$index[1]
plot(matrix_mod[if1_index,],matrix_mod[highest_corr_gene_index,])
rm(matrix_mod)
rm(res_mat)
gsea_tibb <- corr_tibb %>% arrange(desc(cor_r))
genes_named_vector <- gsea_tibb$cor_r
names(genes_named_vector) <- gsea_tibb$gene
genes_named_vector[is.na(genes_named_vector)] <- 0
GOdata <- new("topGOdata",
ontology = "BP", # use biological process ontology
allGenes = genes_named_vector ,
geneSel = function(x)(abs(x)>max(genes_named_vector[1:1000])),
nodeSize = 5,
annot = annFUN.org, mapping = "org.Hs.eg.db", ID = "symbol")
resultks <- runTest(GOdata, algorithm = "elim", statistic = "ks")
gentab <- GenTable(GOdata, ks = resultks, topNodes = 50, numChar = 80)
print(showGroupDensity(GOdata, "GO:0048821", ranks = TRUE)) #erythrocyte dev
print(showGroupDensity(GOdata, "GO:0006783", ranks = TRUE)) #heme biosynth
print(gentab)
res_data <- ScaleData(bmcite,all.genes,
do.scale = FALSE,do.center = TRUE)
rm(bmcite)
matrix_mod<-as.matrix(res_data[["RNA"]]@scale.data)
rm(res_data)
gene<-as.numeric(matrix_mod["ATPIF1",])
correlations_p<-apply(matrix_mod,1,function(x){cor.test(gene,x)$p.value})
correlations_r<-apply(matrix_mod,1,function(x){cor.test(gene,x)$estimate})
corr_tibb <-tibble(cor_p = correlations_p,
cor_r = correlations_r, gene = all.genes,
index = 1:length(all.genes))
corr_tibb <- corr_tibb %>%
filter(gene!="ATPIF1")%>%
mutate(p_adj = cor_p*length(all.genes)) %>% arrange(p_adj)
highest_corr_gene_index <- corr_tibb$index[1]
plot(matrix_mod[if1_index,],matrix_mod[highest_corr_gene_index,])
rm(matrix_mod)
print(corr_tibb)
rm(res_mat)
gsea_tibb <- corr_tibb %>% arrange(desc(cor_r))
genes_named_vector <- gsea_tibb$cor_r
names(genes_named_vector) <- gsea_tibb$gene
genes_named_vector[is.na(genes_named_vector)] <- 0
GOdata <- new("topGOdata",
ontology = "BP", # use biological process ontology
allGenes = genes_named_vector ,
geneSel = function(x)(abs(x)>max(genes_named_vector[1:1000])),
nodeSize = 5,
annot = annFUN.org, mapping = "org.Hs.eg.db", ID = "symbol")
resultks <- runTest(GOdata, algorithm = "elim", statistic = "ks")
gentab <- GenTable(GOdata, ks = resultks, topNodes = 50, numChar = 80)
print(showGroupDensity(GOdata, "GO:0002181", ranks = TRUE)) #translation
print(gentab)
load(file='/Users/bencekover/Library/CloudStorage/OneDrive-UniversityCollegeLondon/duchen lab/rna seq/seurat data/unpacked data/data files/bmcite.rda')
celltypes <- unique(bmcite$celltype.l2)
n_celltypes <- length(celltypes )
cell_clusters = rep(0, length(celltypes ))
for (i in 1:n_celltypes ){
celltype = celltypes[i]
indices = which(bmcite$celltype.l2==celltype)
cell_clusters[indices] = i
}
res_data <- ScaleData(bmcite,all.genes,split.by = "celltype.l2",
do.scale = FALSE,do.center = TRUE)
rm(bmcite)
cell_cluster_indices <- vector()
for (i in 1:n_celltypes){
indices <- which(cell_clusters==i)
cell_cluster_indices<-append(cell_cluster_indices,list(indices))
}
res_mat <- res_data[["RNA"]]@scale.data
rm(res_data)
for (j in 1:n_celltypes) {
print(j / n_celltypes)
indices = unlist(cell_cluster_indices[j])
matrix_mod<-as.matrix(res_mat[,indices])
gene<-as.numeric(matrix_mod["ATPIF1",])
correlations_p<-apply(matrix_mod,1,function(x){cor.test(gene,x)$p.value})
correlations_r<-apply(matrix_mod,1,function(x){cor.test(gene,x)$estimate})
if (j==1){
corr_tibb <-tibble(cor_p = correlations_p,
cor_r = correlations_r, gene = all.genes,
cell_type = celltypes[j],
index = 1:length(all.genes))
}
else{
corr_tibb <-bind_rows(corr_tibb,tibble(cor_p = correlations_p,
cor_r = correlations_r, gene = all.genes,
cell_type = celltypes[j],
index = 1:length(all.genes)))
}
}
rm(res_mat)
for (j in celltypes) {
gsea_tibb <- corr_tibb %>% arrange(desc(cor_r)) %>% filter(cell_type==j)%>%
mutate(p_adj = cor_p*n_celltypes*length(all.genes))
top_genes_tibb <-gsea_tibb %>%  arrange(p_adj) %>% slice(1:1000)
top_genes<- top_genes_tibb$gene
geneList <- ifelse(all.genes %in% top_genes, 1, 0)
names(geneList) <- all.genes
genes_named_vector <- gsea_tibb$cor_r
names(genes_named_vector) <- gsea_tibb$gene
genes_named_vector[is.na(genes_named_vector)] <- 0
GOdata <- new("topGOdata",
ontology = "BP", # use biological process ontology
allGenes = genes_named_vector ,
geneSel = function(x)(abs(x)>max(genes_named_vector[1:100])),
nodeSize = 5,
annot = annFUN.org, mapping = "org.Hs.eg.db", ID = "symbol")
resultks <- runTest(GOdata, algorithm = "elim", statistic = "ks")
gentab <- GenTable(GOdata, ks = resultks, topNodes = 50, numChar = 80)
#goID <- gentab[1, "GO.ID"]
gentab$celltype <- j
print(showGroupDensity(GOdata, "GO:0002181", ranks = TRUE)) #cellular translation
print(gentab)
}
corr_tibb <- corr_tibb %>% arrange(cor_p)
corr_tibb <- corr_tibb[!(corr_tibb$gene=="ATPIF1"),]
final_tibb <- corr_tibb %>% group_by(cell_type) %>%
slice(1:100) %>%  ungroup(cell_type)  %>% group_by(index)%>%
mutate(p_adj = cor_p*n_celltypes*length(all.genes)) %>%
mutate(geom_mean_p_val = exp(mean(log(p_adj))))  %>%
arrange(geom_mean_p_val)
knitr::opts_chunk$set(echo = TRUE)
#BiocManager::install("topGO")
#install.packages("org.Hs.eg.db")
library(tidyverse)
library(Seurat)
library(SeuratData)
library(patchwork)
library(sctransform)
library(readr)
library(data.table)
library(topGO)
load(file='/Users/bencekover/Library/CloudStorage/OneDrive-UniversityCollegeLondon/duchen lab/rna seq/seurat data/unpacked data/data files/bmcite.rda')
filter_data <-function(seuratobj){
seuratobj[["percent.mt"]] <- PercentageFeatureSet(seuratobj, pattern = "^MT-")
min_feat = quantile(seuratobj[["nFeature_RNA"]]$nFeature_RNA, 0.2)
min_count = quantile(seuratobj[["nCount_RNA"]]$nCount_RNA, 0.2)
min_mt = min(quantile(seuratobj[["percent.mt"]]$percent.mt, 0.2), 5)
max_feat = quantile(seuratobj[["nFeature_RNA"]]$nFeature_RNA, 0.98)
max_count = quantile(seuratobj[["nCount_RNA"]]$nCount_RNA, 0.98)
max_mt = quantile(seuratobj[["percent.mt"]]$percent.mt, 0.98)
so <- subset(seuratobj, subset = nFeature_RNA > min_feat  &
nFeature_RNA < max_feat  &
nCount_RNA > min_count &
nCount_RNA < max_count &
percent.mt > min_mt & percent.mt < max_mt)
return(so)
}
bmcite <- filter_data(bmcite)
VlnPlot(bmcite, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
all.genes <- rownames(bmcite)
bmcite <- FindVariableFeatures(bmcite, selection.method = "vst", nfeatures = 2000)
bmcite <- NormalizeData(bmcite, normalization.method = "LogNormalize", scale.factor = 10000)
bmcite <- ScaleData(bmcite, features = all.genes)
bmcite <- RunPCA(bmcite, features = VariableFeatures(object = bmcite))
ElbowPlot(bmcite, 30)
VlnPlot(bmcite, features = c("ATPIF1","ATP5A1"),group.by= "celltype.l2")
print(FindMarkers(bmcite,group.by ="celltype.l2", "Prog_RBC", features = "ATPIF1"))
bmcite <- FindNeighbors(bmcite, dims = 1:25)
bmcite <- FindClusters(bmcite, resolution = 0.2)
bmcite <- RunUMAP(bmcite, dims = 1:25)
DimPlot(bmcite, reduction = "umap",group.by= "celltype.l2", label=T)
FeaturePlot(bmcite, reduction = "umap",features = c("ATPIF1"))
#also finding the index of IF1 and ATP5A
if ("ATPIF1" %in% all.genes) {
print("ATPIF1 is in all genes")
if ("ATP5A1" %in% all.genes) {
print("ATP5A1 is in all genes")
atp5_index <- which(all.genes == "ATP5A1")
}
if1_index <- which(all.genes == "ATPIF1")
}
count_mat <- bmcite[["RNA"]]@data
matrix_mod<-as.matrix(count_mat)
rm(count_mat)
gene<-as.numeric(matrix_mod["ATPIF1",])
correlations_p<-apply(matrix_mod,1,function(x){cor.test(gene,x)$p.value})
correlations_r<-apply(matrix_mod,1,function(x){cor.test(gene,x)$estimate})
corr_tibb <-tibble(cor_p = correlations_p,
cor_r = correlations_r, gene = all.genes,
index = 1:length(all.genes))
corr_tibb <- corr_tibb %>%
filter(gene!="ATPIF1")%>%
mutate(p_adj = cor_p*length(all.genes)) %>% arrange(p_adj)
print(corr_tibb)
highest_corr_gene_index <- corr_tibb$index[1]
plot(matrix_mod[if1_index,],matrix_mod[highest_corr_gene_index,])
rm(matrix_mod)
rm(res_mat)
gsea_tibb <- corr_tibb %>% arrange(desc(cor_r))
genes_named_vector <- gsea_tibb$cor_r
names(genes_named_vector) <- gsea_tibb$gene
genes_named_vector[is.na(genes_named_vector)] <- 0
GOdata <- new("topGOdata",
ontology = "BP", # use biological process ontology
allGenes = genes_named_vector ,
geneSel = function(x)(abs(x)>max(genes_named_vector[1:1000])),
nodeSize = 5,
annot = annFUN.org, mapping = "org.Hs.eg.db", ID = "symbol")
resultks <- runTest(GOdata, algorithm = "elim", statistic = "ks")
gentab <- GenTable(GOdata, ks = resultks, topNodes = 50, numChar = 80)
print(showGroupDensity(GOdata, "GO:0048821", ranks = TRUE)) #erythrocyte dev
print(showGroupDensity(GOdata, "GO:0006783", ranks = TRUE)) #heme biosynth
print(gentab)
res_data <- ScaleData(bmcite,all.genes,
do.scale = FALSE,do.center = TRUE)
rm(bmcite)
matrix_mod<-as.matrix(res_data[["RNA"]]@scale.data)
rm(res_data)
gene<-as.numeric(matrix_mod["ATPIF1",])
correlations_p<-apply(matrix_mod,1,function(x){cor.test(gene,x)$p.value})
correlations_r<-apply(matrix_mod,1,function(x){cor.test(gene,x)$estimate})
corr_tibb <-tibble(cor_p = correlations_p,
cor_r = correlations_r, gene = all.genes,
index = 1:length(all.genes))
corr_tibb <- corr_tibb %>%
filter(gene!="ATPIF1")%>%
mutate(p_adj = cor_p*length(all.genes)) %>% arrange(p_adj)
highest_corr_gene_index <- corr_tibb$index[1]
plot(matrix_mod[if1_index,],matrix_mod[highest_corr_gene_index,])
rm(matrix_mod)
print(corr_tibb)
rm(res_mat)
gsea_tibb <- corr_tibb %>% arrange(desc(cor_r))
genes_named_vector <- gsea_tibb$cor_r
names(genes_named_vector) <- gsea_tibb$gene
genes_named_vector[is.na(genes_named_vector)] <- 0
GOdata <- new("topGOdata",
ontology = "BP", # use biological process ontology
allGenes = genes_named_vector ,
geneSel = function(x)(abs(x)>max(genes_named_vector[1:1000])),
nodeSize = 5,
annot = annFUN.org, mapping = "org.Hs.eg.db", ID = "symbol")
resultks <- runTest(GOdata, algorithm = "elim", statistic = "ks")
gentab <- GenTable(GOdata, ks = resultks, topNodes = 50, numChar = 80)
print(showGroupDensity(GOdata, "GO:0002181", ranks = TRUE)) #translation
print(gentab)
load(file='/Users/bencekover/Library/CloudStorage/OneDrive-UniversityCollegeLondon/duchen lab/rna seq/seurat data/unpacked data/data files/bmcite.rda')
celltypes <- unique(bmcite$celltype.l2)
n_celltypes <- length(celltypes )
cell_clusters = rep(0, length(celltypes ))
for (i in 1:n_celltypes ){
celltype = celltypes[i]
indices = which(bmcite$celltype.l2==celltype)
cell_clusters[indices] = i
}
res_data <- ScaleData(bmcite,all.genes,split.by = "celltype.l2",
do.scale = FALSE,do.center = TRUE)
rm(bmcite)
cell_cluster_indices <- vector()
for (i in 1:n_celltypes){
indices <- which(cell_clusters==i)
cell_cluster_indices<-append(cell_cluster_indices,list(indices))
}
res_mat <- res_data[["RNA"]]@scale.data
rm(res_data)
for (j in 1:n_celltypes) {
print(j / n_celltypes)
indices = unlist(cell_cluster_indices[j])
matrix_mod<-as.matrix(res_mat[,indices])
gene<-as.numeric(matrix_mod["ATPIF1",])
correlations_p<-apply(matrix_mod,1,function(x){cor.test(gene,x)$p.value})
correlations_r<-apply(matrix_mod,1,function(x){cor.test(gene,x)$estimate})
if (j==1){
corr_tibb <-tibble(cor_p = correlations_p,
cor_r = correlations_r, gene = all.genes,
cell_type = celltypes[j],
index = 1:length(all.genes))
}
else{
corr_tibb <-bind_rows(corr_tibb,tibble(cor_p = correlations_p,
cor_r = correlations_r, gene = all.genes,
cell_type = celltypes[j],
index = 1:length(all.genes)))
}
}
corr_tibb <- corr_tibb %>% arrange(cor_p)
corr_tibb <- corr_tibb[!(corr_tibb$gene=="ATPIF1"),]
final_tibb <- corr_tibb %>% group_by(cell_type) %>%
slice(1:100) %>%  ungroup(cell_type)  %>% group_by(index)%>%
mutate(p_adj = cor_p*n_celltypes*length(all.genes)) %>%
mutate(geom_mean_p_val = exp(mean(log(p_adj))))  %>%
arrange(geom_mean_p_val)
print(final_tibb)
highest_corr_gene_index <- final_tibb$index[1]
plot(res_mat[if1_index,],res_mat[highest_corr_gene_index,])
rm(matrix_mod)
rm(res_mat)
for (j in celltypes) {
gsea_tibb <- corr_tibb %>% arrange(desc(cor_r)) %>% filter(cell_type==j)%>%
mutate(p_adj = cor_p*n_celltypes*length(all.genes))
genes_named_vector <- gsea_tibb$cor_r
names(genes_named_vector) <- gsea_tibb$gene
genes_named_vector[is.na(genes_named_vector)] <- 0
GOdata <- new("topGOdata",
ontology = "BP", # use biological process ontology
allGenes = genes_named_vector ,
geneSel = function(x)(abs(x)>max(genes_named_vector[1:100])),
nodeSize = 5,
annot = annFUN.org, mapping = "org.Hs.eg.db", ID = "symbol")
resultks <- runTest(GOdata, algorithm = "elim", statistic = "ks")
gentab <- GenTable(GOdata, ks = resultks, topNodes = 50, numChar = 80)
#goID <- gentab[1, "GO.ID"]
gentab$celltype <- j
print(showGroupDensity(GOdata, "GO:0002181", ranks = TRUE)) #cellular translation
print(gentab)
}
load(file='/Users/bencekover/Library/CloudStorage/OneDrive-UniversityCollegeLondon/duchen lab/rna seq/seurat data/unpacked data/data files/cbmc.rda')
load(file='/Users/bencekover/Library/CloudStorage/OneDrive-UniversityCollegeLondon/duchen lab/rna seq/seurat data/unpacked data/data files/panc8.rda')
#BiocManager::install("topGO")
#install.packages("org.Hs.eg.db")
library(tidyverse)
library(Seurat)
library(SeuratData)
library(patchwork)
library(sctransform)
library(readr)
library(data.table)
library(topGO)
load(file='/Users/bencekover/Library/CloudStorage/OneDrive-UniversityCollegeLondon/duchen lab/rna seq/seurat data/unpacked data/data files/panc8.rda')
h
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE)
#BiocManager::install("topGO")
#install.packages("org.Hs.eg.db")
library(tidyverse)
library(Seurat)
library(SeuratData)
library(patchwork)
library(sctransform)
library(readr)
library(data.table)
library(topGO)
load(file='/Users/bencekover/Library/CloudStorage/OneDrive-UniversityCollegeLondon/duchen lab/rna seq/seurat data/unpacked data/data files/panc8.rda')
library(RFQTL)
library(randomForest)
library(qqman)
#NEW
#d<-read.table(file = '/Users/bencekover/bioinformatics/projects/segregants/updated_genotype_matrix.tsv', sep = '\t', header = TRUE)
d<-read.table(file = '/Users/bencekover/bioinformatics/projects/segregants/updated_genotype_matrix_final_pos.tsv', sep = '\t', header = TRUE)
d<-d[c(1:(nrow(d)-12)),]
genotype1<-d[,-c(1:4)]
genotype1<-data.matrix(genotype1)
genotype1<-t(genotype1)
#loading in the filtering measurements
phenotype1<-read.csv("/Users/bencekover/Library/CloudStorage/OneDrive-Personal/MSci Bahler lab/S.-Pombe-MLPs - Github/Bence folder/Image processing - Adhesion assay/segregants_emm_p.csv")
phenotype1<-phenotype1[which(phenotype1$strain %in% rownames(genotype1)),]
strainNames1 <- phenotype1$strain
phenotype1 <- phenotype1$ratio
sampleInfo1 <- sapply(strainNames1,FUN=function(x){
which(rownames(genotype1)==x)
})
mode(genotype1) <- "integer"
mappingData1 <- preMap(genotype=genotype1,
phenotype=phenotype1,
sampleInfo=sampleInfo1,
scale=T,
)
r=rfMapper(mappingData = mappingData1,
permute = F,
nforest = 100,#was 100
ntree = 100)
#Below the wd is the folder in which the permutations folder is (not IN the permutation folder)
setwd("/Users/bencekover/Library/CloudStorage/OneDrive-Personal/MSci Bahler lab/S.-Pombe-MLPs - Github/Bence folder/QTL mapping/permutations_emm_p/")
pValues1 <- pEst(path="permutations/",
scores=r,
markersPerIteration = 350,
printProg = T,
pCorrection = "none")
pValuesX1 <- pValues1[mappingData1$genotype2group]
#df for export to make Manhattan plot in Python
df <- data.frame (haplogroup  = mappingData1$genotype2group,
chr = d$chromosome,
p_val= pValues1[mappingData1$genotype2group])
write.csv(df,"/Users/bencekover/Library/CloudStorage/OneDrive-Personal/MSci Bahler lab/S.-Pombe-MLPs - Github/Bence folder/Manhattan plot/dataresults.csv")
#These steps (until markerPositions) are not useful for the way I presented the results
chrVec1 <- d$chromosome
QTL_list1 <- QTLgrouper(pmat = pValuesX1,
sigThreshold = 0.01,
corThreshold = 0.10,
distThreshold = 1000,
genotype = genotype1,
chrVec = chrVec1)
