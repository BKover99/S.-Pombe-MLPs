genes_named_vector
genes_named_vector
genesInTerm(GOdata)
genesInTerm(GOdata, `GO:0006682`)
genesInTerm(GOdata, whichGO=`GO:0006682`)
genesInTerm(`GO:0006682`)
genesInTerm(`0006682`)
genesInTerm(0006682)
View(GOdata)
genesInTerm(resultsks3)
View(resultks3)
genesInTerm(gentab_fin$GO.ID)
genesInTerm(gentab_fin$GO.ID, "character")
gentab$genes<- genesInTerm(GOdata)
genes1<- genesInTerm(GOdata)
for (i in gentab$GO.ID){
gentab$genes = genes1$i
}
gentab
gentab<- genesInTerm(GOdata)
genes1<- genesInTerm(GOdata)
for (i in gentab$GO.ID){
gentab$genes = genes1$i
}
View(gentab)
genes1<- genesInTerm(GOdata)
gentab<- genes1
for (i in 1:length(gentab$GO.ID)){
a=gentab$GO.ID[i]
gentab$genes[i] = genes1$a
}
GOdata <- new("topGOdata",
ontology = "BP", # use biological process ontology
allGenes = genes_named_vector ,
geneSel = function(x)(x>median(genes_named_vector)),
nodeSize = 5,
annot = annFUN.org, mapping = "org.Hs.eg.db", ID = "symbol")
resultks <- runTest(GOdata, algorithm = "elim", statistic = "ks")
gentab <- GenTable(GOdata, ks = resultks, topNodes = length(GOdata@graph@nodes), numChar = 80)
gentab <- gentab %>% mutate( dataset="MELAS", cell="all" )
genes1<- genesInTerm(GOdata)
gentab$genes<- genes1
for (i in 1:length(gentab$GO.ID)){
a=gentab$GO.ID[i]
gentab$genes[i] = genes1$a
}
genes1$a
genes1
genes1<- genesInTerm(GOdata)
gentab$genes<- genes1
for (i in 1:length(gentab$GO.ID)){
a=gentab$GO.ID[i]
gentab$genes[i] = genes1$a
}
genes1$`GO:0000002`
View(gentab)
genes1$a
genes1$gentab$GO.ID[2]
genes1$gentab$GO.ID[3
]
gentab$GO.ID[3
]
genes1$"GO:0000398"
genes1$"GO:0002181"
a
genes1$a
paste(genes1$a)
genes1$a
genes1$paste(a)
genes1$a
paste(genes1$a)
genes1[a]
genes1<- genesInTerm(GOdata)
gentab$genes<- genes1
for (i in 1:length(gentab$GO.ID)){
a=gentab$GO.ID[i]
gentab$genes[i] = genes1[a]
}
View(GOdata)
View(gentab)
genes1$a
genes1$GO:0002181
genes1$a
genes1$"GO:0002181"
genes1<- genesInTerm(GOdata)
gentab$genes<- genes1
for (i in 1:length(gentab$GO.ID)){
a=gentab$GO.ID[i]
gentab$genes[i] = genes1[a]
}
genes2<- genesInTerm(GOdata2)
gentab2$genes2<- genes2
for (i in 1:length(gentab2$GO.ID)){
a=gentab2$GO.ID[i]
gentab2$genes2[i] = genes2[a]
}
genes3<- genesInTerm(GOdata3)
gentab3$genes3<- genes3
for (i in 1:length(gentab3$GO.ID)){
a=gentab3$GO.ID[i]
gentab3$genes3[i] = genes[a]
}
genes3<- genesInTerm(GOdata3)
gentab3$genes3<- genes3
for (i in 1:length(gentab3$GO.ID)){
a=gentab3$GO.ID[i]
gentab3$genes3[i] = genes3[a]
}
gentab_fin <- bind_rows(gentab,gentab2,gentab3) %>% mutate(p_adj = p.adjust(ks), method="bonferroni") %>% group_by(GO.ID)%>% filter(p_adj <0.05)
print(gentab_fin)
write.csv(gentab_fin,"MELAS_GO.csv")
View(gentab_fin)
gentab_fin <- bind_rows(gentab,gentab2,gentab3) %>% mutate(p_adj = p.adjust(ks), method="bonferroni") %>% group_by(GO.ID)%>% filter(p_adj <0.05)
print(gentab_fin)
write.csv(gentab_fin,"MELAS_GO.csv")
gentab_fin <- apply(gentab_fin,2,as.character)
write.csv(gentab_fin,"MELAS_GO.csv")
gentab_fin <- apply(gentab_fin,2,as.character)
write.csv(gentab_fin,"MELAS_GO.csv")
knitr::opts_chunk$set(echo = TRUE)
#BiocManager::install("topGO")
#install.packages("org.Hs.eg.db")
library(tidyverse)
library(Seurat)
library(SeuratData)
library(patchwork)
library(sctransform)
library(readr)
library(data.table)
library(topGO)
load(file='/Users/bencekover/Library/CloudStorage/OneDrive-UniversityCollegeLondon/duchen lab/rna seq/seurat data/unpacked data/data files/bmcite.rda')
knitr::opts_chunk$set(echo = TRUE)
#BiocManager::install("topGO")
#install.packages("org.Hs.eg.db")
library(tidyverse)
library(Seurat)
library(SeuratData)
library(patchwork)
library(sctransform)
library(readr)
library(data.table)
library(readxl)
library(topGO)
InstallData("panc8")
knitr::opts_chunk$set(echo = TRUE)
pombe_seq <- read_excel("/Users/bencekover/Library/CloudStorage/OneDrive-UniversityCollegeLondon/MSci Bahler lab/S.-Pombe-biofilm/external data/Saint_2019/rna_seq_pombe.xlsx",sheet="Table_S4")
#BiocManager::install("topGO")
#install.packages("org.Hs.eg.db")
library(tidyverse)
library(Seurat)
library(SeuratData)
library(patchwork)
library(sctransform)
library(readr)
library(data.table)
library(readxl)
library(topGO)
pombe_seq <- read_excel("/Users/bencekover/Library/CloudStorage/OneDrive-UniversityCollegeLondon/MSci Bahler lab/S.-Pombe-biofilm/external data/Saint_2019/rna_seq_pombe.xlsx",sheet="Table_S4")
map <- fread("/Users/bencekover/Library/CloudStorage/OneDrive-UniversityCollegeLondon/MSci Bahler lab/S.-Pombe-biofilm/external data/gene_IDs_names_products.tsv", header=F)
for (i in 1:length(pombe_seq$Systematic_ID)){
index = which(map$V1==pombe_seq$Systematic_ID[i])
if (length(index) == 1){
if (map$V3[index] != ""){
pombe_seq$Systematic_ID[i] = map$V3[index]
}}
}
pombe_seq_obj <- CreateSeuratObject(counts = pombe_seq[,-1],row.names=pombe_seq$Systematic_ID )%>%
NormalizeData()  %>%
#SCTransform(vst.flavor = "v2") %>%
FindVariableFeatures()%>%
ScaleData()%>%
RunPCA() %>%
FindNeighbors(dims = 1:30) %>%
RunUMAP(dims = 1:30) %>%
FindClusters()
DefaultAssay(pombe_seq_obj) <- "RNA"
print(FeaturePlot(pombe_seq_obj, reduction = "umap",features = c("gsf2")))
count_mat <- pombe_seq_obj[["RNA"]]@data
matrix_mod<-as.matrix(count_mat)
rm(count_mat)
gene<-as.numeric(matrix_mod["mbx2",])
correlations_p<-apply(matrix_mod,1,function(x){cor.test(gene,x)$p.value})
correlations_r<-apply(matrix_mod,1,function(x){cor.test(gene,x)$estimate})
all.genes <- rownames(pombe_seq_obj)
corr_tibb <-tibble(cor_p = correlations_p,
cor_r = correlations_r, gene = all.genes,
index = 1:length(all.genes))
corr_tibb <- corr_tibb %>%
filter(gene!="mbx2")%>%
mutate(p_adj = cor_p*length(all.genes)) %>% arrange(p_adj)
print(corr_tibb)
pombe_seq_obj[["RNA"]]@data
count_mat <- pombe_seq_obj[["RNA"]]@data
matrix_mod<-as.matrix(count_mat)
rm(count_mat)
gene<-as.numeric(matrix_mod["snf5",])
correlations_p<-apply(matrix_mod,1,function(x){cor.test(gene,x)$p.value})
correlations_r<-apply(matrix_mod,1,function(x){cor.test(gene,x)$estimate})
all.genes <- rownames(pombe_seq_obj)
corr_tibb <-tibble(cor_p = correlations_p,
cor_r = correlations_r, gene = all.genes,
index = 1:length(all.genes))
corr_tibb <- corr_tibb %>%
filter(gene!="snf5")%>%
mutate(p_adj = cor_p*length(all.genes)) %>% arrange(p_adj)
print(corr_tibb)
View(corr_tibb)
count_mat <- pombe_seq_obj[["RNA"]]@data
matrix_mod<-as.matrix(count_mat)
rm(count_mat)
gene<-as.numeric(matrix_mod["gsf2",])
correlations_p<-apply(matrix_mod,1,function(x){cor.test(gene,x)$p.value})
correlations_r<-apply(matrix_mod,1,function(x){cor.test(gene,x)$estimate})
all.genes <- rownames(pombe_seq_obj)
corr_tibb <-tibble(cor_p = correlations_p,
cor_r = correlations_r, gene = all.genes,
index = 1:length(all.genes))
corr_tibb <- corr_tibb %>%
filter(gene!="gsf2")%>%
mutate(p_adj = cor_p*length(all.genes)) %>% arrange(p_adj)
print(corr_tibb)
View(corr_tibb)
count_mat <- pombe_seq_obj[["RNA"]]@data
matrix_mod<-as.matrix(count_mat)
rm(count_mat)
gene<-as.numeric(matrix_mod['SPNCRNA.1524',])
correlations_p<-apply(matrix_mod,1,function(x){cor.test(gene,x)$p.value})
correlations_r<-apply(matrix_mod,1,function(x){cor.test(gene,x)$estimate})
all.genes <- rownames(pombe_seq_obj)
corr_tibb <-tibble(cor_p = correlations_p,
cor_r = correlations_r, gene = all.genes,
index = 1:length(all.genes))
corr_tibb <- corr_tibb %>%
filter(gene!='SPNCRNA.1524')%>%
mutate(p_adj = cor_p*length(all.genes)) %>% arrange(p_adj)
print(corr_tibb)
install.packages("languageserver")
install.packages("rmarkdown")
file.path(R.home("bin"), "R")
install.packages("affy")
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("affy")
library(affy)
library(affy)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("affy")
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("affy")
library(RFQTL)
library(randomForest)
library(qqman)
#OLD
d<-read.table(file = '/Users/bencekover/Library/CloudStorage/OneDrive-UniversityCollegeLondon/MSci Bahler lab/S.-Pombe-biofilm/Bence folder/QTL mapping/SupplementaryDataset_S7_genotype.tsv', sep = '\t', header = TRUE)
d<-d[c(1:(nrow(d)-12)),]
genotype1<-d[,-c(1:4)]
genotype1<-data.matrix(genotype1)
genotype1<-t(genotype1)
#loading in the filtering measurements
phenotype1<-read.csv('/Users/bencekover/Library/CloudStorage/OneDrive-UniversityCollegeLondon/MSci Bahler lab/S.-Pombe-biofilm/Bence folder/QTL mapping/filtering_phenotypes.csv')
phenotype1<-phenotype1[,-1]
phenotype1<-phenotype1[which(phenotype1$Strain %in% rownames(genotype1)),]
strainNames1 <- phenotype1$Strain
phenotype1 <- phenotype1$X.flocc
sampleInfo1 <- sapply(strainNames1,FUN=function(x){
which(rownames(genotype1)==x)
})
mode(genotype1) <- "integer"
mappingData1 <- preMap(genotype=genotype1,
phenotype=phenotype1,
sampleInfo=sampleInfo1,
scale=T,
)
r=rfMapper(mappingData = mappingData1,
permute = F,
nforest = 100,#was 100
ntree = 100)
#Below the wd is the folder in which the permutations folder is (not IN the permutation folder)
setwd("/Users/bencekover/Library/CloudStorage/OneDrive-UniversityCollegeLondon/MSci Bahler lab/S.-Pombe-biofilm/Bence folder/QTL mapping/permutations/")
#The path below is the permutations folder
pValues1 <- pEst(path="permutations_testing old/",
scores=r,
markersPerIteration = 350,
printProg = T,
pCorrection = "none")
pValuesX1 <- pValues1[mappingData1$genotype2group]
#df for export to make Manhattan plot in Python
df <- data.frame (haplogroup  = mappingData1$genotype2group,
chr = d$chromosome,
p_val= pValues1[mappingData1$genotype2group])
write.csv(df,"/Users/bencekover/Library/CloudStorage/OneDrive-UniversityCollegeLondon/MSci Bahler lab/S.-Pombe-biofilm/Bence folder/Manhattan plot/dataresults_old_filtering.csv")
#These steps (until markerPositions) are not useful for the way I presented the results
chrVec1 <- d$chromosome
QTL_list1 <- QTLgrouper(pmat = pValuesX1,
sigThreshold = 0.001,
corThreshold = 0.80,
distThreshold = 25000,
genotype = genotype1,
chrVec = chrVec1)
markerPositions1 <- d[,c(1,2)]
markerPositions1$chromosome<-gsub("chromosome_1",1,markerPositions1$chromosome)
markerPositions1$chromosome<-gsub("chromosome_2",2,markerPositions1$chromosome)
markerPositions1$chromosome<-gsub("chromosome_3",3,markerPositions1$chromosome)
markerPositions1[,3]=markerPositions1$position
#the writeQTL is what is in the tutorial but I didn't find it useful as a visualisation of results
writeQTL(QTLlist = QTL_list1,traitNames = "Flocc",markerPositions = markerPositions1,path="myResults_new_filtering.qtl")
qtl1 <- readQTL(path = "myResults_new_filtering.qtl")
qtl1
#Presenting results
#barplot
barplot(-log10(pValuesX1))
abline(h=-log10(0.05/length(pValues1)),col="red")
#manhattan plot
results.tab=markerPositions1[,-3]
results.tab[,3]=pValuesX1
colnames(results.tab)=c("CHR","BP","P")
results.tab=results.tab[-which(is.na(results.tab)),]
results.tab$CHR=as.numeric(unlist(results.tab$CHR))
results.tab[,4]=rep("snp",length(results.tab$CHR))
colnames(results.tab)[4]="SNP"
manhattan(results.tab,ylim = c(0,7), suggestiveline = F, genomewideline = F,cex = 0.7)
abline(h=-log10(0.05/length(pValues1)),col="red")
abline(h=-log10(1/20000),col="blue")
text(x=200,y=-log10(0.05/length(pValues1))+0.15,labels="                   p=7.2e-05",col="red",cex=0.7)
qtl1
QTL_list1 <- QTLgrouper(pmat = pValuesX1,
sigThreshold = 0.0001,
corThreshold = 0.90,
distThreshold = 5000,
genotype = genotype1,
chrVec = chrVec1)
markerPositions1 <- d[,c(1,2)]
markerPositions1$chromosome<-gsub("chromosome_1",1,markerPositions1$chromosome)
markerPositions1$chromosome<-gsub("chromosome_2",2,markerPositions1$chromosome)
markerPositions1$chromosome<-gsub("chromosome_3",3,markerPositions1$chromosome)
markerPositions1[,3]=markerPositions1$position
#the writeQTL is what is in the tutorial but I didn't find it useful as a visualisation of results
writeQTL(QTLlist = QTL_list1,traitNames = "Flocc",markerPositions = markerPositions1,path="myResults_new_filtering.qtl")
qtl1 <- readQTL(path = "myResults_new_filtering.qtl")
qtl1
QTL_list1 <- QTLgrouper(pmat = pValuesX1,
sigThreshold = 0.0001,
corThreshold = 0.99,
distThreshold = 1000,
genotype = genotype1,
chrVec = chrVec1)
markerPositions1 <- d[,c(1,2)]
markerPositions1$chromosome<-gsub("chromosome_1",1,markerPositions1$chromosome)
markerPositions1$chromosome<-gsub("chromosome_2",2,markerPositions1$chromosome)
markerPositions1$chromosome<-gsub("chromosome_3",3,markerPositions1$chromosome)
markerPositions1[,3]=markerPositions1$position
#the writeQTL is what is in the tutorial but I didn't find it useful as a visualisation of results
writeQTL(QTLlist = QTL_list1,traitNames = "Flocc",markerPositions = markerPositions1,path="myResults_new_filtering.qtl")
qtl1 <- readQTL(path = "myResults_new_filtering.qtl")
qtl1
#Presenting results
#barplot
barplot(-log10(pValuesX1))
abline(h=-log10(0.05/length(pValues1)),col="red")
#manhattan plot
results.tab=markerPositions1[,-3]
results.tab[,3]=pValuesX1
colnames(results.tab)=c("CHR","BP","P")
results.tab=results.tab[-which(is.na(results.tab)),]
results.tab$CHR=as.numeric(unlist(results.tab$CHR))
results.tab[,4]=rep("snp",length(results.tab$CHR))
colnames(results.tab)[4]="SNP"
manhattan(results.tab,ylim = c(0,7), suggestiveline = F, genomewideline = F,cex = 0.7)
abline(h=-log10(0.05/length(pValues1)),col="red")
abline(h=-log10(1/20000),col="blue")
text(x=200,y=-log10(0.05/length(pValues1))+0.15,labels="                   p=7.2e-05",col="red",cex=0.7)
#save as csv
write.csv(all.data_final, file = "/Users/bencekover/Downloads/all.data_final.csv")
library(affy)
files = list.files("/Users/bencekover/Downloads/GSE31642_RAW/arrays",
full.names = TRUE)
affy.data = ReadAffy(filenames = files)
eset.mas5 = mas5(affy.data)
exprSet.nologs = exprs(eset.mas5)
# List the column (chip) names
colnames(exprSet.nologs)
colnames(exprSet.nologs) = c("wt1", "wt2", "fkh2d_1", "fkh2d_2",
"fkh2-S2A_1", "fkh2-S2A_2")
heatmap(exprSet.nologs)
#take logs
exprSet = log(exprSet.nologs, 2)
data.mas5calls = mas5calls(affy.data)
# Get the actual A/P calls
data.mas5calls.calls = exprs(data.mas5calls)
#calc means
wt_mean = apply(exprSet[, c("wt1","wt2")], 1, mean)
fkh2d_mean = apply(exprSet[, c("fkh2d_1", "fkh2d_2")], 1, mean)
fkh2s2a_mean = apply(exprSet[, c("fkh2-S2A_1", "fkh2-S2A_2")], 1, mean)
#calc log fold difs
wt_fkh2d = wt_mean - fkh2d_mean
wt_fkh2s2a = wt_mean - fkh2s2a_mean
fkh2d_fkh2s2a = fkh2d_mean - fkh2s2a_mean
#all data to include means and logfold changes
all.data = cbind(exprSet, wt_mean, fkh2d_mean, fkh2s2a_mean, wt_fkh2d, wt_fkh2s2a, fkh2d_fkh2s2a)
colnames(all.data)
#now calculating p values for all genes. welch test two sided
wt_fkh2d_pval =  apply(exprSet, 1, function(x) {
t.test(x[1:2], x[3:4], var.equal = FALSE)$p.value })
wt_fkh2s2a_pval =  apply(exprSet, 1, function(x) {
t.test(x[1:2], x[5:6], var.equal = FALSE)$p.value })
fkh2d_fkh2s2a_pval =  apply(exprSet, 1, function(x) {
t.test(x[3:4], x[5:6], var.equal = FALSE)$p.value })
# Concatenate all A/P calls for brain and liver
AP = apply(data.mas5calls.calls, 1, paste, collapse = "")
# Get the probsets where the 4 calls are not 'AAAA'
genes.present = names(AP[AP != "AAAAAA"])
# How many probetset/genes are present?
length(genes.present)
# Get all data for probesets that are present on at least on chip.
exprSet.present = exprSet[genes.present, ]
wt_fkh2d_pval_present =  wt_fkh2d_pval[genes.present]
wt_fkh2s2a_pval_present =  wt_fkh2s2a_pval[genes.present]
fkh2d_fkh2s2a_pval_present =  fkh2d_fkh2s2a_pval[genes.present]
wt_fkh2d_pval_present_adjusted = p.adjust(wt_fkh2d_pval_present, method = 'fdr')
wt_fkh2s2a_pval_present_adjusted = p.adjust(wt_fkh2s2a_pval_present, method = 'fdr')
fkh2d_fkh2s2a_pval_present_adjusted = p.adjust(fkh2d_fkh2s2a_pval_present, method = 'fdr')
#now order these
wt_fkh2d_pval_present_adjusted_ordered = wt_fkh2d_pval_present_adjusted[order(wt_fkh2d_pval_present_adjusted)]
wt_fkh2s2a_pval_present_adjusted_ordered = wt_fkh2s2a_pval_present_adjusted[order(wt_fkh2s2a_pval_present_adjusted)]
fkh2d_fkh2s2a_pval_present_adjusted_ordered = fkh2d_fkh2s2a_pval_present_adjusted[order(fkh2d_fkh2s2a_pval_present_adjusted)]
wt_fkh2s2a_pval_present_adjusted_ordered[1:10]
#rename the rownames based on this file /Users/bencekover/Downloads/TFS-Assets_LSG_Support-Files_Yeast_2-na36-annot-csv/Yeast_2.na36.annot.csv. heaer is 21th row
mapping_names = read.table("/Users/bencekover/Downloads/TFS-Assets_LSG_Support-Files_Yeast_2-na36-annot-csv/Yeast_2.na36.annot.csv", header = TRUE, sep = ",")
mapping_names = mapping_names[,c(1,7)]
colnames(mapping_names) = c("gene", "ID")
head(mapping_names)
#turn all.data to a data frame
all.data = as.data.frame(all.data)
#create new column
all.data_final= cbind(gene = rownames(all.data), all.data)
#iterate through gene column in all.data, find the row in mappingnames that matches in the first column, and replace the gene with  the value in column Transcript ID(Array Design)
for (i in 1:nrow(all.data_final)){
all.data_final[i,1] = mapping_names[mapping_names$gene == all.data_final[i,1],2]
}
#save as csv
write.csv(all.data_final, file = "/Users/bencekover/Downloads/all.data_final.csv")
library(affy)
files = list.files("/Users/bencekover/Downloads/GSE31642_RAW/arrays",
full.names = TRUE)
affy.data = ReadAffy(filenames = files)
eset.mas5 = mas5(affy.data)
exprSet.nologs = exprs(eset.mas5)
# List the column (chip) names
colnames(exprSet.nologs)
colnames(exprSet.nologs) = c("wt1", "wt2", "fkh2d_1", "fkh2d_2",
"fkh2-S2A_1", "fkh2-S2A_2")
heatmap(exprSet.nologs)
#take logs
exprSet = log(exprSet.nologs, 2)
data.mas5calls = mas5calls(affy.data)
# Get the actual A/P calls
data.mas5calls.calls = exprs(data.mas5calls)
#calc means
wt_mean = apply(exprSet[, c("wt1","wt2")], 1, mean)
fkh2d_mean = apply(exprSet[, c("fkh2d_1", "fkh2d_2")], 1, mean)
fkh2s2a_mean = apply(exprSet[, c("fkh2-S2A_1", "fkh2-S2A_2")], 1, mean)
#calc log fold difs
wt_fkh2d = wt_mean - fkh2d_mean
wt_fkh2s2a = wt_mean - fkh2s2a_mean
fkh2d_fkh2s2a = fkh2d_mean - fkh2s2a_mean
#all data to include means and logfold changes
all.data = cbind(exprSet, wt_mean, fkh2d_mean, fkh2s2a_mean, wt_fkh2d, wt_fkh2s2a, fkh2d_fkh2s2a)
colnames(all.data)
#now calculating p values for all genes. welch test two sided
wt_fkh2d_pval =  apply(exprSet, 1, function(x) {
t.test(x[1:2], x[3:4], var.equal = FALSE)$p.value })
wt_fkh2s2a_pval =  apply(exprSet, 1, function(x) {
t.test(x[1:2], x[5:6], var.equal = FALSE)$p.value })
fkh2d_fkh2s2a_pval =  apply(exprSet, 1, function(x) {
t.test(x[3:4], x[5:6], var.equal = FALSE)$p.value })
# Concatenate all A/P calls for brain and liver
AP = apply(data.mas5calls.calls, 1, paste, collapse = "")
# Get the probsets where the 4 calls are not 'AAAA'
genes.present = names(AP[AP != "AAAAAA"])
# How many probetset/genes are present?
length(genes.present)
# Get all data for probesets that are present on at least on chip.
exprSet.present = exprSet[genes.present, ]
wt_fkh2d_pval_present =  wt_fkh2d_pval[genes.present]
wt_fkh2s2a_pval_present =  wt_fkh2s2a_pval[genes.present]
fkh2d_fkh2s2a_pval_present =  fkh2d_fkh2s2a_pval[genes.present]
wt_fkh2d_pval_present_adjusted = p.adjust(wt_fkh2d_pval_present, method = 'fdr')
wt_fkh2s2a_pval_present_adjusted = p.adjust(wt_fkh2s2a_pval_present, method = 'fdr')
fkh2d_fkh2s2a_pval_present_adjusted = p.adjust(fkh2d_fkh2s2a_pval_present, method = 'fdr')
#now order these
wt_fkh2d_pval_present_adjusted_ordered = wt_fkh2d_pval_present_adjusted[order(wt_fkh2d_pval_present_adjusted)]
wt_fkh2s2a_pval_present_adjusted_ordered = wt_fkh2s2a_pval_present_adjusted[order(wt_fkh2s2a_pval_present_adjusted)]
fkh2d_fkh2s2a_pval_present_adjusted_ordered = fkh2d_fkh2s2a_pval_present_adjusted[order(fkh2d_fkh2s2a_pval_present_adjusted)]
wt_fkh2s2a_pval_present_adjusted_ordered[1:10]
#rename the rownames based on this file /Users/bencekover/Downloads/TFS-Assets_LSG_Support-Files_Yeast_2-na36-annot-csv/Yeast_2.na36.annot.csv. heaer is 21th row
mapping_names = read.table("/Users/bencekover/Downloads/TFS-Assets_LSG_Support-Files_Yeast_2-na36-annot-csv/Yeast_2.na36.annot.csv", header = TRUE, sep = ",")
mapping_names = mapping_names[,c(1,7)]
colnames(mapping_names) = c("gene", "ID")
head(mapping_names)
#turn all.data to a data frame
all.data = as.data.frame(all.data)
#create new column
all.data_final= cbind(gene = rownames(all.data), all.data)
#iterate through gene column in all.data, find the row in mappingnames that matches in the first column, and replace the gene with  the value in column Transcript ID(Array Design)
for (i in 1:nrow(all.data_final)){
all.data_final[i,1] = mapping_names[mapping_names$gene == all.data_final[i,1],2]
}
#save as csv
write.csv(all.data_final, file = "/Users/bencekover/Library/CloudStorage/OneDrive-UniversityCollegeLondon/MSci Bahler lab/S.-Pombe-biofilm/Bence folder/Analysis of microarray datasets/szilagyi_final.csv")
mas5?
